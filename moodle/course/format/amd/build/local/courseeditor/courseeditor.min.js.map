{"version":3,"sources":["../../../src/local/courseeditor/courseeditor.js"],"names":["courseId","Error","_editing","_supportscomponents","getServerCourseState","stateData","log","error","setInitialState","isEditing","stateKey","newState","JSON","stringify","previousState","Storage","get","set","Date","now","setup","editing","supportscomponents","ajax","call","methodname","args","courseid","courseState","parse","course","section","cm","Exporter","key","dataJson","data","value","notification","exception","Reactive"],"mappings":"gTAgBA,OACA,OACA,OACA,OACA,O,muHA0Be,C,yBAQK,C,8FASCA,C,iGAET,KAAKA,Q,sBACC,IAAIC,CAAAA,KAAJ,uBAAyBD,CAAzB,4CAAoE,KAAKA,QAAzE,E,QAIV,KAAKE,QAAL,IACA,KAAKC,mBAAL,IAEA,KAAKH,QAAL,CAAgBA,CAAhB,C,wBAKsB,MAAKI,oBAAL,E,QAAlBC,C,6DAEAC,UAAIC,KAAJ,CAAU,2CAAV,EACAD,UAAIC,KAAJ,O,kCAIJ,KAAKC,eAAL,CAAqBH,CAArB,EAGA,GAAI,KAAKI,SAAT,CAAoB,CAChB,KAAKC,QAAL,CAAgB,IACnB,CAFD,IAEO,CAEGC,CAFH,CAEcC,IAAI,CAACC,SAAL,CAAeR,CAAf,CAFd,CAGGS,CAHH,CAGmBC,CAAO,CAACC,GAAR,kBAAsBhB,CAAtB,iBAHnB,CAIH,GAAIc,CAAa,GAAKH,CAAtB,CAAgC,CAC5BI,CAAO,CAACE,GAAR,kBAAsBjB,CAAtB,iBAA8CW,CAA9C,EACAI,CAAO,CAACE,GAAR,kBAAsBjB,CAAtB,cAA2CkB,IAAI,CAACC,GAAL,EAA3C,CACH,CACD,KAAKT,QAAL,CAAgBK,CAAO,CAACC,GAAR,kBAAsBhB,CAAtB,cACnB,C,6KAUSoB,C,CAAO,SACjB,KAAKlB,QAAL,WAAgBkB,CAAK,CAACC,OAAtB,mBACA,KAAKlB,mBAAL,WAA2BiB,CAAK,CAACE,kBAAjC,kBACH,C,oMAQ6BC,WAAKC,IAAL,CAAU,CAAC,CACjCC,UAAU,CAAE,6BADqB,CAEjCC,IAAI,CAAE,CACFC,QAAQ,CAAE,KAAK3B,QADb,CAF2B,CAAD,CAAV,EAKtB,CALsB,C,QAApB4B,C,QAOAvB,C,CAAYO,IAAI,CAACiB,KAAL,CAAWD,CAAX,C,6BAGdE,MAAM,CAAE,E,CACRC,OAAO,CAAE,E,CACTC,EAAE,CAAE,E,EACD3B,C,6KAoBG,CACV,MAAO,IAAI4B,UAAJ,CAAa,IAAb,CACV,C,wDAsBeC,C,CAAK,CACjB,GAAI,KAAKzB,SAAL,EAAkB,CAAC,KAAKC,QAA5B,CAAsC,CAClC,QACH,CACD,GAAMyB,CAAAA,CAAQ,CAAGpB,CAAO,CAACC,GAAR,kBAAsB,KAAKhB,QAA3B,aAAuCkC,CAAvC,EAAjB,CACA,GAAI,CAACC,CAAL,CAAe,CACX,QACH,CAED,GAAI,CACA,GAAMC,CAAAA,CAAI,CAAGxB,IAAI,CAACiB,KAAL,CAAWM,CAAX,CAAb,CACA,GAAI,QAAAC,CAAI,WAAJA,SAAAA,CAAI,CAAE1B,QAAN,IAAmB,KAAKA,QAA5B,CAAsC,CAClC,QACH,CACD,MAAO0B,CAAAA,CAAI,CAACC,KACf,CAAC,MAAO9B,CAAP,CAAc,CACZ,QACH,CACJ,C,wDASe2B,C,CAAKG,C,CAAO,CAExB,GAAI,KAAK5B,SAAT,CAAoB,CAChB,QACH,CACD,GAAM2B,CAAAA,CAAI,CAAG,CACT1B,QAAQ,CAAE,KAAKA,QADN,CAET2B,KAAK,CAALA,CAFS,CAAb,CAIA,MAAOtB,CAAAA,CAAO,CAACE,GAAR,kBAAsB,KAAKjB,QAA3B,aAAuCkC,CAAvC,EAA8CtB,IAAI,CAACC,SAAL,CAAeuB,CAAf,CAA9C,CACV,C,iNAWiBV,C,uBAAAA,C,yFAEcA,C,6DAGxBY,UAAaC,SAAb,OAEA,4CAAe,WAAf,E,2JAxFQ,OACZ,iBAAO,KAAKrC,QAAZ,kBACH,C,6CAgBuB,OACpB,iBAAO,KAAKC,mBAAZ,kBACH,C,cAnIwBqC,U","sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\nimport {Reactive} from 'core/reactive';\nimport notification from 'core/notification';\nimport Exporter from 'core_courseformat/local/courseeditor/exporter';\nimport log from 'core/log';\nimport ajax from 'core/ajax';\nimport * as Storage from 'core/sessionstorage';\n\n/**\n * Main course editor module.\n *\n * All formats can register new components on this object to create new reactive\n * UI components that watch the current course state.\n *\n * @module     core_courseformat/local/courseeditor/courseeditor\n * @class     core_courseformat/local/courseeditor/courseeditor\n * @copyright  2021 Ferran Recio <ferran@moodle.com>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\nexport default class extends Reactive {\n\n    /**\n     * The current state cache key\n     *\n     * The state cache is considered dirty if the state changes from the last page or\n     * if the page has editing mode on.\n     *\n     * @attribute stateKey\n     * @type number|null\n     * @default 1\n     * @package\n     */\n    stateKey = 1;\n\n    /**\n     * The current page section return\n     * @attribute sectionReturn\n     * @type number\n     * @default 0\n     */\n    sectionReturn = 0;\n\n    /**\n     * Set up the course editor when the page is ready.\n     *\n     * The course can only be loaded once per instance. Otherwise an error is thrown.\n     *\n     * @param {number} courseId course id\n     */\n    async loadCourse(courseId) {\n\n        if (this.courseId) {\n            throw new Error(`Cannot load ${courseId}, course already loaded with id ${this.courseId}`);\n        }\n\n        // Default view format setup.\n        this._editing = false;\n        this._supportscomponents = false;\n\n        this.courseId = courseId;\n\n        let stateData;\n\n        try {\n            stateData = await this.getServerCourseState();\n        } catch (error) {\n            log.error(\"EXCEPTION RAISED WHILE INIT COURSE EDITOR\");\n            log.error(error);\n            return;\n        }\n\n        this.setInitialState(stateData);\n\n        // In editing mode, the session cache is considered dirty always.\n        if (this.isEditing) {\n            this.stateKey = null;\n        } else {\n            // Check if the last state is the same as the cached one.\n            const newState = JSON.stringify(stateData);\n            const previousState = Storage.get(`course/${courseId}/staticState`);\n            if (previousState !== newState) {\n                Storage.set(`course/${courseId}/staticState`, newState);\n                Storage.set(`course/${courseId}/stateKey`, Date.now());\n            }\n            this.stateKey = Storage.get(`course/${courseId}/stateKey`);\n        }\n    }\n\n    /**\n     * Setup the current view settings\n     *\n     * @param {Object} setup format, page and course settings\n     * @param {boolean} setup.editing if the page is in edit mode\n     * @param {boolean} setup.supportscomponents if the format supports components for content\n     */\n    setViewFormat(setup) {\n        this._editing = setup.editing ?? false;\n        this._supportscomponents = setup.supportscomponents ?? false;\n    }\n\n    /**\n     * Load the current course state from the server.\n     *\n     * @returns {Object} the current course state\n     */\n    async getServerCourseState() {\n        const courseState = await ajax.call([{\n            methodname: 'core_courseformat_get_state',\n            args: {\n                courseid: this.courseId,\n            }\n        }])[0];\n\n        const stateData = JSON.parse(courseState);\n\n        return {\n            course: {},\n            section: [],\n            cm: [],\n            ...stateData,\n        };\n    }\n\n    /**\n     * Return the current edit mode.\n     *\n     * Components should use this method to check if edit mode is active.\n     *\n     * @return {boolean} if edit is enabled\n     */\n    get isEditing() {\n        return this._editing ?? false;\n    }\n\n    /**\n     * Return a data exporter to transform state part into mustache contexts.\n     *\n     * @return {Exporter} the exporter class\n     */\n    getExporter() {\n        return new Exporter(this);\n    }\n\n    /**\n     * Return if the current course support components to refresh the content.\n     *\n     * @returns {boolean} if the current content support components\n     */\n    get supportComponents() {\n        return this._supportscomponents ?? false;\n    }\n\n    /**\n     * Get a value from the course editor static storage if any.\n     *\n     * The course editor static storage uses the sessionStorage to store values from the\n     * components. This is used to prevent unnecesary template loadings on every page. However,\n     * the storage does not work if no sessionStorage can be used (in debug mode for example),\n     * if the page is in editing mode or if the initial state change from the last page.\n     *\n     * @param {string} key the key to get\n     * @return {boolean|string} the storage value or false if cannot be loaded\n     */\n    getStorageValue(key) {\n        if (this.isEditing || !this.stateKey) {\n            return false;\n        }\n        const dataJson = Storage.get(`course/${this.courseId}/${key}`);\n        if (!dataJson) {\n            return false;\n        }\n        // Check the stateKey.\n        try {\n            const data = JSON.parse(dataJson);\n            if (data?.stateKey !== this.stateKey) {\n                return false;\n            }\n            return data.value;\n        } catch (error) {\n            return false;\n        }\n    }\n\n    /**\n     * Stores a value into the course editor static storage if available\n     *\n     * @param {String} key the key to store\n     * @param {*} value the value to store (must be compatible with JSON,stringify)\n     * @returns {boolean} true if the value is stored\n     */\n    setStorageValue(key, value) {\n        // Values cannot be stored on edit mode.\n        if (this.isEditing) {\n            return false;\n        }\n        const data = {\n            stateKey: this.stateKey,\n            value,\n        };\n        return Storage.set(`course/${this.courseId}/${key}`, JSON.stringify(data));\n    }\n\n    /**\n     * Dispatch a change in the state.\n     *\n     * Usually reactive modules throw an error directly to the components when something\n     * goes wrong. However, course editor can directly display a notification.\n     *\n     * @method dispatch\n     * @param {mixed} args any number of params the mutation needs.\n     */\n    async dispatch(...args) {\n        try {\n            await super.dispatch(...args);\n        } catch (error) {\n            // Display error modal.\n            notification.exception(error);\n            // Force unlock all elements.\n            super.dispatch('unlockAll');\n        }\n    }\n}\n"],"file":"courseeditor.min.js"}